document.addEventListener('DOMContentLoaded', () => {
    const headerFocusToggle = document.getElementById('headerFocusToggle'); // Toggle switch m·ªõi

    const pomodoroTimerEl = document.getElementById('pomodoroTimer');
    const pomodoroStatusEl = document.getElementById('pomodoroStatus');
    const pomodoroDurationInput = document.getElementById('pomodoroDuration');
    const startPomodoroBtn = document.getElementById('startPomodoro');
    const stopPomodoroBtn = document.getElementById('stopPomodoro');
    const openOptionsPageLink = document.getElementById('openOptionsPage');
    const themeToggleBtn = document.getElementById('themeToggleBtn');
    const langToggleBtn = document.getElementById('langToggleBtn');
    const openInfoPageLink = document.getElementById('openInfoPage');
    // Elements cho Quick Block
    const quickBlockUrlInput = document.getElementById('quickBlockUrl');
    const quickBlockBtn = document.getElementById('quickBlockBtn');
    const quickBlockStatusEl = document.getElementById('quickBlockStatus'); // Note: This element is not in the provided popup.html
    const quickBlockedSitesListEl = document.getElementById('quickBlockedSitesList');

    let currentPomodoroInterval = null;
    let currentTheme = 'light'; // M·∫∑c ƒë·ªãnh l√† light
    let currentLang = 'vi'; // M·∫∑c ƒë·ªãnh l√† Ti·∫øng Vi·ªát

    const translations = {
        en: {
            popupTitle: "Focus Assistant",
            themeToggleTitleLight: "Switch to Dark Mode",
            themeToggleTitleDark: "Switch to Light Mode",
            langToggleTitleVI: "Switch to English",
            langToggleTitleEN: "Switch to Vietnamese",
            focusModeHeader: "Focus Mode",
            statusLabel: "Status",
            statusLoading: "Loading...",
            statusOn: "ON",
            statusOff: "OFF",
            toggleFocusDefault: "Toggle",
            toggleFocusOn: "Turn Focus Mode ON",
            toggleFocusOff: "Turn Focus Mode OFF",
            strictModeTooltipFocus: "Strict Mode is ON. You cannot turn off Focus Mode during the current session.",
            pomodoroHeader: "Pomodoro Timer",
            pomodoroStatusDefault: "Not started",
            pomodoroStatusRunning: "Running... (ends at {time})",
            pomodoroDurationLabel: "Duration (minutes):",
            startPomodoro: "Start Pomodoro",
            stopPomodoro: "Stop Pomodoro",
            strictModeTooltipPomodoro: "Strict Mode is ON. You cannot stop Pomodoro.",
            pomodoroAlertPositive: "Pomodoro duration must be greater than 0.",
            openOptionsLink: "Settings",
            openOptionsLinkTitle: "Open Settings Page",
            openInfoLink: "Help & Info",
            openInfoLinkTitle: "View help, user information, and other products",
            quickBlockHeader: "Quick Block Site",
            quickBlockPlaceholder: "e.g., example.com",
            quickBlockButton: "Add",
            quickBlockSuccess: "Site '{site}' added to block list!",
            quickBlockErrorInvalid: "Invalid URL format.",
            quickBlockErrorExists: "Site '{site}' is already blocked.",
            removeButton: "Remove",
            quickBlockedSitesEmpty: "No sites blocked yet."
        }

        ,
        vi: {
            popupTitle: "Focus Assistant",
            themeToggleTitleLight: "Chuy·ªÉn sang Giao di·ªán T·ªëi",
            themeToggleTitleDark: "Chuy·ªÉn sang Giao di·ªán S√°ng",
            langToggleTitleVI: "Chuy·ªÉn sang Ti·∫øng Anh",
            langToggleTitleEN: "Chuy·ªÉn sang Ti·∫øng Vi·ªát",
            focusModeHeader: "Ch·∫ø ƒë·ªô T·∫≠p trung",
            statusLabel: "Tr·∫°ng th√°i",
            statusLoading: "ƒêang t·∫£i...",
            statusOn: "B·∫¨T",
            statusOff: "T·∫ÆT",
            toggleFocusDefault: "B·∫≠t/T·∫Øt",
            toggleFocusOn: "B·∫≠t Ch·∫ø ƒë·ªô T·∫≠p trung",
            toggleFocusOff: "T·∫Øt Ch·∫ø ƒë·ªô T·∫≠p trung",
            strictModeTooltipFocus: "Strict Mode ƒëang B·∫¨T. B·∫°n kh√¥ng th·ªÉ t·∫Øt Ch·∫ø ƒë·ªô T·∫≠p trung trong phi√™n l√†m vi·ªác hi·ªán t·∫°i.",
            pomodoroHeader: "H·∫πn gi·ªù Pomodoro",
            pomodoroStatusDefault: "Ch∆∞a b·∫Øt ƒë·∫ßu",
            pomodoroStatusRunning: "ƒêang ch·∫°y... (k·∫øt th√∫c l√∫c {time})",
            pomodoroDurationLabel: "Th·ªùi gian (ph√∫t):",
            startPomodoro: "B·∫Øt ƒë·∫ßu Pomodoro",
            stopPomodoro: "D·ª´ng Pomodoro",
            strictModeTooltipPomodoro: "Strict Mode ƒëang B·∫¨T. B·∫°n kh√¥ng th·ªÉ d·ª´ng Pomodoro.",
            pomodoroAlertPositive: "Th·ªùi gian Pomodoro ph·∫£i l·ªõn h∆°n 0.",
            openOptionsLink: "T√πy ch·ªçn",
            openOptionsLinkTitle: "M·ªü trang T√πy ch·ªçn",
            openInfoLink: "Tr·ª£ gi√∫p & Th√¥ng tin",
            openInfoLinkTitle: "Xem h∆∞·ªõng d·∫´n, th√¥ng tin v√† c√°c s·∫£n ph·∫©m kh√°c",
            quickBlockHeader: "Ch·∫∑n nhanh trang web",
            quickBlockPlaceholder: "v√≠ d·ª•: example.com",
            quickBlockButton: "Th√™m",
            quickBlockSuccess: "Trang '{site}' ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch ch·∫∑n!",
            quickBlockErrorInvalid: "ƒê·ªãnh d·∫°ng URL kh√¥ng h·ª£p l·ªá.",
            quickBlockErrorExists: "Trang '{site}' ƒë√£ c√≥ trong danh s√°ch ch·∫∑n.",
            removeButton: "X√≥a",
            quickBlockedSitesEmpty: "Ch∆∞a c√≥ trang n√†o b·ªã ch·∫∑n."
        }
    };

    // --- QU·∫¢N L√ù GIAO DI·ªÜN (THEME) ---
    function applyTheme(theme) {
        document.body.classList.remove('theme-light', 'theme-dark');

        document.body.classList.add(`theme-${theme}`);
        themeToggleBtn.textContent = theme === 'light' ? 'üåô' : '‚òÄÔ∏è'; // M·∫∑t trƒÉng cho light, m·∫∑t tr·ªùi cho dark
        currentTheme = theme;
        themeToggleBtn.title = translations[currentLang][theme === 'light' ? 'themeToggleTitleLight' : 'themeToggleTitleDark'];
    }

    themeToggleBtn.addEventListener('click', () => {
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';

        chrome.storage.sync.set({
            theme: newTheme
        }

            , () => {
                applyTheme(newTheme);
            }

        );
    }

    );

    // --- QU·∫¢N L√ù NG√îN NG·ªÆ ---
    function applyLanguage(lang) {
        currentLang = lang;
        document.documentElement.lang = lang; // Set lang attribute on <html>

        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.dataset.langKey;

            if (translations[lang] && translations[lang][key]) {
                el.textContent = translations[lang][key];
            }
        }

        );

        langToggleBtn.textContent = lang === 'vi' ? 'üáªüá≥' : 'üá¨üáß';
        langToggleBtn.title = translations[lang][lang === 'vi' ? 'langToggleTitleVI' : 'langToggleTitleEN'];
        // Update theme button title as it also depends on language
        themeToggleBtn.title = translations[lang][currentTheme === 'light' ? 'themeToggleTitleLight' : 'themeToggleTitleDark'];
        openOptionsPageLink.title = translations[lang].openOptionsLinkTitle;
        openInfoPageLink.title = translations[lang].openInfoLinkTitle;
        // Re-apply dynamic texts that might have been set by updateUI
        loadSettings(); // This will call updateUI which should now use the new currentLang
    }

    langToggleBtn.addEventListener('click', () => {
        const newLang = currentLang === 'vi' ? 'en' : 'vi';

        chrome.storage.sync.set({
            lang: newLang
        }

            , () => {
                applyLanguage(newLang);
            }

        );
    }

    );

    function loadInitialState() {
        chrome.storage.sync.get(['theme', 'lang'], (result) => {
            let themeToApply = result.theme;
            let langToApply = result.lang;
            let settingsToSave = {};
            let defaultsDetected = false;

            if (!themeToApply) {
                // Ph√°t hi·ªán giao di·ªán h·ªá th·ªëng
                if (window.matchMedia) { // Ki·ªÉm tra tr√¨nh duy·ªát c√≥ h·ªó tr·ª£ kh√¥ng
                    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    themeToApply = systemPrefersDark ? 'dark' : 'light';
                } else {
                    themeToApply = 'light'; // M·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c
                }
                settingsToSave.theme = themeToApply;
                defaultsDetected = true;
            }

            if (!langToApply) {
                // Ph√°t hi·ªán ng√¥n ng·ªØ tr√¨nh duy·ªát
                const browserLang = (navigator.language || 'en').toLowerCase(); // M·∫∑c ƒë·ªãnh 'en' n·∫øu kh√¥ng c√≥
                langToApply = browserLang.startsWith('vi') ? 'vi' : 'en'; // ∆Øu ti√™n Ti·∫øng Vi·ªát n·∫øu tr√¨nh duy·ªát l√† 'vi'
                settingsToSave.lang = langToApply;
                defaultsDetected = true;
            }

            if (defaultsDetected) {
                // L∆∞u c√°c c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh ph√°t hi·ªán ƒë∆∞·ª£c. Listener onChanged s·∫Ω x·ª≠ l√Ω vi·ªác √°p d·ª•ng ch√∫ng.
                chrome.storage.sync.set(settingsToSave, () => {
                    console.log('System default theme/lang set in storage:', settingsToSave);
                });
            } else {
                // Giao di·ªán v√† ng√¥n ng·ªØ ƒë√£ c√≥ trong storage, √°p d·ª•ng tr·ª±c ti·∫øp v√† t·∫£i c√°c c√†i ƒë·∫∑t kh√°c.
                currentTheme = themeToApply;
                currentLang = langToApply;
                applyTheme(currentTheme);
                applyLanguage(currentLang); // H√†m n√†y ƒë√£ g·ªçi loadSettings()
            }
        });
    }

    loadInitialState();

    // --- KH·ªûI T·∫†O V√Ä C·∫¨P NH·∫¨T UI ---
    function updateUI(settings) {

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i Ch·∫ø ƒë·ªô T·∫≠p trung
        if (settings.isFocusModeActive) {
            headerFocusToggle.checked = true; // C·∫≠p nh·∫≠t tr·∫°ng th√°i toggle switch m·ªõi
        }

        else {
            headerFocusToggle.checked = false; // C·∫≠p nh·∫≠t tr·∫°ng th√°i toggle switch m·ªõi
        }

        // Logic Strict Mode cho n√∫t b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô t·∫≠p trung
        const isPomodoroActive = settings.pomodoro && settings.pomodoro.isActive && settings.pomodoro.endTime > Date.now();
        const activeSchedule = getActiveSchedule(settings.schedules || []); // C·∫ßn h√†m getActiveSchedule ·ªü ƒë√¢y

        if (settings.isStrictModActive && (isPomodoroActive || activeSchedule)) {
            headerFocusToggle.disabled = true; // √Åp d·ª•ng cho toggle switch m·ªõi
            headerFocusToggle.parentElement.title = translations[currentLang].strictModeTooltipFocus; // ƒê·∫∑t title cho label bao ngo√†i
        }

        else {
            headerFocusToggle.disabled = false; // √Åp d·ª•ng cho toggle switch m·ªõi
            headerFocusToggle.parentElement.title = settings.isFocusModeActive ? translations[currentLang].toggleFocusOff : translations[currentLang].toggleFocusOn;
        }

        // C·∫≠p nh·∫≠t Pomodoro
        if (settings.pomodoro && settings.pomodoro.isActive && settings.pomodoro.endTime > Date.now()) {
            startPomodoroBtn.classList.add('hidden');
            stopPomodoroBtn.classList.remove('hidden');
            pomodoroDurationInput.disabled = true;
            pomodoroStatusEl.textContent = translations[currentLang].pomodoroStatusRunning.replace('{time}', new Date(settings.pomodoro.endTime).toLocaleTimeString());

            if (settings.isStrictModActive) {
                stopPomodoroBtn.disabled = true;
                stopPomodoroBtn.title = translations[currentLang].strictModeTooltipPomodoro;
            }

            else {
                stopPomodoroBtn.disabled = false;
                stopPomodoroBtn.title = "";
            }

            // Ensure button texts are updated according to language
            startPomodoroBtn.textContent = translations[currentLang].startPomodoro;
            stopPomodoroBtn.textContent = translations[currentLang].stopPomodoro;
            updatePomodoroCountdown(settings.pomodoro.endTime);
        }

        else {
            startPomodoroBtn.classList.remove('hidden');
            stopPomodoroBtn.classList.add('hidden');
            pomodoroDurationInput.disabled = false;
            pomodoroStatusEl.textContent = translations[currentLang].pomodoroStatusDefault;
            pomodoroTimerEl.textContent = '--:--';
            startPomodoroBtn.textContent = translations[currentLang].startPomodoro;
            stopPomodoroBtn.textContent = translations[currentLang].stopPomodoro;

            if (currentPomodoroInterval) {
                clearInterval(currentPomodoroInterval);
                currentPomodoroInterval = null;
            }
        }

        if (settings.pomodoro && settings.pomodoro.duration) {
            pomodoroDurationInput.value = settings.pomodoro.duration;
        }

        // Update static texts that might not be covered by initial applyLanguage if their keys were not on the element yet
        // C·∫≠p nh·∫≠t placeholder cho quick block input
        if (quickBlockUrlInput) {
            quickBlockUrlInput.placeholder = translations[currentLang].quickBlockPlaceholder;
        }

        // Render danh s√°ch ch·∫∑n nhanh
        renderQuickBlockedSitesList(settings.blockedSites || []);
    }

    function updatePomodoroCountdown(endTime) {
        if (currentPomodoroInterval) {
            clearInterval(currentPomodoroInterval);
        }

        currentPomodoroInterval = setInterval(() => {
            const now = Date.now();
            const timeLeft = Math.max(0, endTime - now); // ms

            if (timeLeft === 0) {
                pomodoroTimerEl.textContent = '00:00';
                // Tr·∫°ng th√°i s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi storage.onChanged khi background x·ª≠ l√Ω xong
                clearInterval(currentPomodoroInterval);
                currentPomodoroInterval = null;
                return;
            }

            const minutes = Math.floor(timeLeft / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            pomodoroTimerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

            , 1000);
    }

    // H√†m tr·ª£ gi√∫p
    function getActiveSchedule(schedules) {
        if (!schedules || schedules.length === 0) return null;
        const now = new Date();
        const currentDay = now.getDay();
        const currentTime = now.getHours() * 100 + now.getMinutes();
        const dayMapping = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
        const currentDayStr = dayMapping[currentDay];

        for (const schedule of schedules) {
            if (!schedule.isActive || !schedule.days || !schedule.startTime || !schedule.endTime) continue;

            if (schedule.days.includes(currentDayStr)) {
                const [startH, startM] = schedule.startTime.split(':').map(Number);
                const [endH, endM] = schedule.endTime.split(':').map(Number);
                const scheduleStart = startH * 100 + startM;
                const scheduleEnd = endH * 100 + endM;

                if (currentTime >= scheduleStart && currentTime < scheduleEnd) {
                    return schedule;
                }
            }
        }

        return null;
    }

    // --- T∆Ø∆†NG T√ÅC V·ªöI STORAGE ---
    function loadSettings() {
        chrome.storage.sync.get(['isFocusModeActive',
            'pomodoro',
            'schedules',
            'isStrictModActive'

        ], (result) => {

            // K·∫øt h·ª£p v·ªõi theme v√† lang hi·ªán t·∫°i ƒë·ªÉ updateUI
            const fullSettings = {
                ...result,
                theme: currentTheme, // ƒê·∫£m b·∫£o theme hi·ªán t·∫°i ƒë∆∞·ª£c truy·ªÅn ƒëi
                lang: currentLang // ƒê·∫£m b·∫£o lang hi·ªán t·∫°i ƒë∆∞·ª£c truy·ªÅn ƒëi
            }

                ;
            updateUI(fullSettings);
        }

        );
    }

    // L·∫Øng nghe thay ƒë·ªïi t·ª´ background ho·∫∑c c√°c trang kh√°c
    chrome.storage.onChanged.addListener((changes, namespace) => {
        if (namespace === 'sync') {
            let settingsLoadedDueToLangChange = false;
            if (changes.theme) {
                applyTheme(changes.theme.newValue); // currentTheme ƒë∆∞·ª£c c·∫≠p nh·∫≠t b√™n trong applyTheme
            }
            if (changes.lang) {
                applyLanguage(changes.lang.newValue); // currentLang ƒë∆∞·ª£c c·∫≠p nh·∫≠t b√™n trong applyLanguage, h√†m n√†y c≈©ng g·ªçi loadSettings
                settingsLoadedDueToLangChange = true;
            }

            // Ch·ªâ g·ªçi loadSettings n·∫øu n√≥ ch∆∞a ƒë∆∞·ª£c g·ªçi b·ªüi applyLanguage
            // ƒë·ªÉ c·∫≠p nh·∫≠t c√°c ph·∫ßn UI kh√°c c√≥ th·ªÉ ph·ª• thu·ªôc v√†o theme ho·∫∑c c√°c c√†i ƒë·∫∑t kh√°c ƒë√£ thay ƒë·ªïi.
            if (!settingsLoadedDueToLangChange) {
                loadSettings();
            }
        }
    });

    // X·ª≠ l√Ω s·ª± ki·ªán cho toggle switch m·ªõi ·ªü header
    headerFocusToggle.addEventListener('change', async () => {
        const {
            isFocusModeActive, isStrictModActive, pomodoro, schedules
        }

            = await chrome.storage.sync.get(['isFocusModeActive', 'isStrictModActive', 'pomodoro', 'schedules'
            ]);

        const isPomodoroSessionActive = pomodoro && pomodoro.isActive && pomodoro.endTime > Date.now();
        const activeSchedule = getActiveSchedule(schedules || []);

        if (isStrictModActive && (isPomodoroSessionActive || activeSchedule) && isFocusModeActive) {
            alert(translations[currentLang].strictModeTooltipFocus);
            return;
        }

        chrome.storage.sync.set({
            isFocusModeActive: headerFocusToggle.checked // L·∫•y tr·∫°ng th√°i t·ª´ checkbox
        }

        );
        // UI s·∫Ω t·ª± c·∫≠p nh·∫≠t qua listener `chrome.storage.onChanged`
    }

    );

    startPomodoroBtn.addEventListener('click', () => {
        const duration = parseInt(pomodoroDurationInput.value, 10);

        if (duration > 0) {

            // G·ª≠i y√™u c·∫ßu b·∫Øt ƒë·∫ßu Pomodoro t·ªõi background script
            chrome.runtime.sendMessage({
                action: "startPomodoro", duration: duration
            }

                , response => {
                    if (chrome.runtime.lastError) {
                        console.error("Error sending startPomodoro message:", chrome.runtime.lastError.message);
                    }

                    else {
                        console.log("Start Pomodoro request sent.");
                    }
                }

            );

        }

        else {
            alert(translations[currentLang].pomodoroAlertPositive);
        }
    }

    );

    stopPomodoroBtn.addEventListener('click', async () => {
        const {
            isStrictModActive, pomodoro
        }

            = await chrome.storage.sync.get(['isStrictModActive', 'pomodoro']);

        if (isStrictModActive && pomodoro.isActive) {
            alert(translations[currentLang].strictModeTooltipPomodoro);
            return;
        }

        chrome.runtime.sendMessage({
            action: "stopPomodoro"
        }

            , response => {
                if (chrome.runtime.lastError) {
                    console.error("Error sending stopPomodoro message:", chrome.runtime.lastError.message);
                }

                else {
                    console.log("Stop Pomodoro request sent.");
                }
            }

        );
    }

    );

    // M·ªü trang t√πy ch·ªçn
    openOptionsPageLink.addEventListener('click', (e) => {
        e.preventDefault();
        chrome.runtime.openOptionsPage();
    }

    );

    openInfoPageLink.addEventListener('click', (e) => {
        e.preventDefault();

        const infoPagePath = `/info/info_${currentTheme}_${currentLang}.html`;
        chrome.tabs.create({
            url: chrome.runtime.getURL(infoPagePath)
        }

        );
    }

    );

    // --- X·ª¨ L√ù QUICK BLOCK ---
    if (quickBlockBtn) {
        quickBlockBtn.addEventListener('click', async () => {
            const url = quickBlockUrlInput.value.trim().toLowerCase();
            if (quickBlockStatusEl) quickBlockStatusEl.textContent = ''; // X√≥a th√¥ng b√°o c≈©

            if (!url) {
                quickBlockUrlInput.focus();
                return;
            }

            try {
                let domain = url;
                // T·ª± ƒë·ªông tr√≠ch xu·∫•t hostname v√† lo·∫°i b·ªè 'www.'
                if (url.includes('://')) {
                    try {
                        domain = new URL(url).hostname;
                    } catch (e) {
                        // N·∫øu URL kh√¥ng h·ª£p l·ªá, th·ª≠ x·ª≠ l√Ω nh∆∞ m·ªôt domain ƒë∆°n gi·∫£n
                    }
                }
                domain = domain.replace(/^www\./i, '');
                // Ch·ªâ l·∫•y ph·∫ßn domain, kh√¥ng l·∫•y path ho·∫∑c query params
                domain = domain.split('/')[0].split('?')[0];

                // Regex ki·ªÉm tra ƒë·ªãnh d·∫°ng domain c∆° b·∫£n (sau khi ƒë√£ c·ªë g·∫Øng chu·∫©n h√≥a)
                if (!domain || !/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}$/i.test(domain)) {
                    // Ki·ªÉm tra domain c∆° b·∫£n, kh√¥ng ki·ªÉm tra path
                    if (quickBlockStatusEl) quickBlockStatusEl.textContent = translations[currentLang].quickBlockErrorInvalid;
                    return;
                }


                const {
                    blockedSites = []
                }

                    = await chrome.storage.sync.get('blockedSites');

                if (blockedSites.includes(domain)) {
                    if (quickBlockStatusEl) quickBlockStatusEl.textContent = translations[currentLang].quickBlockErrorExists.replace('{site}', domain);
                }

                else {
                    const newBlockedSites = [...blockedSites, domain];

                    await chrome.storage.sync.set({
                        blockedSites: newBlockedSites
                    }

                    );
                    if (quickBlockStatusEl) quickBlockStatusEl.textContent = translations[currentLang].quickBlockSuccess.replace('{site}', domain);
                    quickBlockUrlInput.value = ''; // X√≥a input sau khi th√™m
                }
            }

            catch (e) {
                console.error("Error in quick block:", e);
                if (quickBlockStatusEl) quickBlockStatusEl.textContent = translations[currentLang].quickBlockErrorInvalid;
            }

            // T·ª± ƒë·ªông x√≥a th√¥ng b√°o sau v√†i gi√¢y
            if (quickBlockStatusEl) {
                setTimeout(() => {
                    if (quickBlockStatusEl) quickBlockStatusEl.textContent = '';
                }
                    , 3000);
            }
        }

        );
    }

    // --- RENDER DANH S√ÅCH CH·∫∂N NHANH ---
    function renderQuickBlockedSitesList(sites) {
        if (!quickBlockedSitesListEl) return;
        quickBlockedSitesListEl.innerHTML = ''; // X√≥a danh s√°ch c≈©

        if (!sites || sites.length === 0) {
            return;
        }

        sites.forEach(site => {
            const li = document.createElement('li');
            li.textContent = site;

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '&times;'; // K√Ω t·ª± 'x'
            removeBtn.title = translations[currentLang].removeButton;
            removeBtn.classList.add('remove-site-btn');

            removeBtn.addEventListener('click', () => {
                removeQuickBlockedSite(site);
            }

            );

            li.appendChild(removeBtn);
            quickBlockedSitesListEl.appendChild(li);
        }

        );
    }

    async function removeQuickBlockedSite(siteToRemove) {
        const {
            blockedSites = []
        }

            = await chrome.storage.sync.get('blockedSites');
        const newBlockedSites = blockedSites.filter(site => site !== siteToRemove);

        await chrome.storage.sync.set({
            blockedSites: newBlockedSites
        }

        );
        // UI s·∫Ω t·ª± c·∫≠p nh·∫≠t qua listener `chrome.storage.onChanged` -> `loadSettings` -> `updateUI` -> `renderQuickBlockedSitesList`
    }

    // T·∫£i c√†i ƒë·∫∑t ban ƒë·∫ßu (ƒë√£ ƒë∆∞·ª£c g·ªçi b·ªüi loadInitialState)
    // loadSettings();
}
);